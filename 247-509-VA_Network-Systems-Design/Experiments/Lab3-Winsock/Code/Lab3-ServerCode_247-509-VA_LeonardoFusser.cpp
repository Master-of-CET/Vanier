/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* FileName: UDP_server.cpp
*
* Lab 3 - Socket Programming
* Network Systems Design (247-509-VA)
* Day Yann Fong
*
* Name: Leonardo Fusser (1946995)
*
* Description: This code receives a UDP packet that contains a customized long message entered by the
*			   user through a command prompt (on client). This program (server) can be run by using the
*			   corresponding executable file generated by Visual Studio after building the solution.
*			   The location of the executable file depends on how the Visual Studio solution was
*			   created. With the executable file open in a command prompt (or any other terminal software),
*		       the user can see all the messages being received by the server. If the server receives a "beep"
*			   keyword, the computer will produce a beep or if the server receives a "end" keyword, the server
*			   will terminate and stop receiving any new data. Various precautionary messearues have been 
*			   implemented below.
*
* REVISION HISTORY:
*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* Author        	Date                Version     Comments on this revision
*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* Leonardo Fusser	29 September 2021	v1.0.0		Created UDP_server.cpp file
* Leonardo Fusser	24 October 2021		v1.0.1		Completed UDP_server.cpp file
*
*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/


#include <iostream>					//Allows for input-output stream capabilities.
#include <winsock2.h>				//Allows for the use of Winsock APIs.
#include <Windows.h>				//Allows for the use of Windows APIs.
#pragma comment(lib,"ws2_32.lib")	//Import library.
#include <stdio.h>					//Allows for standard input-output capabilities.
#include <string.h>					//Allows for the use of string functions.

#define WIN32_LEAN_AND_MEAN
#define BUFFER_SIZE			4096	//Allocates 4'096 bytes.

/*Server main code.*/
int main(void) {
	WSADATA		wsaData;
	SOCKET		SvrSocket;
	sockaddr_in	ServerInfo;

	char RECEIVE[BUFFER_SIZE];							//Array that will store customized long message entered by the user in a command prompt.
	char* BEEP_RESULT;									//Pointer.
	char BEEP_CHECK[] = "beep";							//Array that stores the keyword needed to trigger beep function.
	char* END_RESULT;									//Pointer.
	char END_CHECK[] = "end";							//Array that stores the keyword needed to trigger program termination.

	int svr_length = (int)sizeof(struct sockaddr_in);	//Local variable.
	int svr_result;										//" ".
	int i = 0;											//" ".
	int j = 0;											//" ".


	/**************************************************************************************************/
	//[Step1: Initialize winsock]
	/*If initializing Winsock returns an error...*/
	if (WSAStartup(0x0101, &wsaData) != 0) {
		fprintf(stderr, "Could not initialize winsock! [Error number: %d]\n", WSAGetLastError());
		fprintf(stderr, "Goodbye!\n");
		WSACleanup();	//Cleanup.
		exit(0);		//Exit.
	}
	/*Otherwise, continue with program execution.*/
	else {
		fprintf(stderr, "----------------------------------------------------------------------\n");
		fprintf(stderr, "Successfully initialized winsock! Proceeding to next step...\n");
	}
	/**************************************************************************************************/

	/**************************************************************************************************/
	//[Step2: Create datagram socket]
	SvrSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);	//Creates a UDP socket.
	/*If creating a socket returns an error...*/
	if (SvrSocket == INVALID_SOCKET) {
		fprintf(stderr, "Could not create datagram socket! [Error number: %d]\n", WSAGetLastError());
		fprintf(stderr, "Goodbye!\n");
		WSACleanup();	//Cleanup.
		exit(0);		//Exit.
	}
	/**************************************************************************************************/

	/***********************************************************************************************/
	//[Step3: Setup info of server/client (address, port, type, etc...) and socket binding]
	memset((void*)&ServerInfo, '\0', sizeof(struct sockaddr_in));		//Clears struct.
	ServerInfo.sin_family = AF_INET;									//Set to IPv4.
	ServerInfo.sin_port = htons(60001);									//Sets port number.
	ServerInfo.sin_addr.S_un.S_un_b.s_b1 = 127;							//IP byte 1.
	ServerInfo.sin_addr.S_un.S_un_b.s_b2 = 0;							//IP byte 2.
	ServerInfo.sin_addr.S_un.S_un_b.s_b3 = 0;							//IP byte 3.
	ServerInfo.sin_addr.S_un.S_un_b.s_b4 = 1;							//IP byte 4.
	fprintf(stderr, "Successfully initialized server info! Proceeding to next step...\n");

	/*If socket binding fails...*/
	if (bind(SvrSocket, (struct sockaddr*)&ServerInfo,sizeof(struct sockaddr_in)) == -1){
		fprintf(stderr, "----------------------------------------------------------------------\n");
		fprintf(stderr, "Could not bind address to socket! [Error number: %d]\n", WSAGetLastError());	//Prints last known error.
		fprintf(stderr, "Goodbye!\n");
		fprintf(stderr, "----------------------------------------------------------------------\n");
		closesocket(SvrSocket);		//Close the socket.
		WSACleanup();				//Cleanup.
		exit(0);					//Exit.
	}
	fprintf(stderr, "----------------------------------------------------------------------\n");
	fprintf(stderr, "Waiting for client to send data...\n");
	/***********************************************************************************************/

	/*********************************************************************************************************/
	//[Step 4: Receive datum(s) and print datum(s) to console UNTIL "end" keyword is received]
	while (1) {
		svr_result = recvfrom(SvrSocket, RECEIVE, BUFFER_SIZE, 0, (struct sockaddr*)&ServerInfo, &svr_length);	//Receives new datum.
		
		/*If new datum has been received...*/
		if (svr_result != SOCKET_ERROR) {
			printf("Message received: ");
			while (RECEIVE[i] != '\0') {	//Unless end-of-string has reached...
				printf("%c", RECEIVE[i]);	//Print individual elements of received datum.
				i++;						//Increase "i" so next individual elements of received datum can be printed.
			}
			i = 0;							//Reset "i" when done printing all individual elements from received datum on one line, so that next received datum can be printed.
			printf("\n");					//Skip line for printing next received datum on new line.
		}
		
		BEEP_RESULT = strstr(_strlwr(RECEIVE), BEEP_CHECK);														//Check to see if "beep" keyword has been received.
		END_RESULT = strstr(_strlwr(RECEIVE), END_CHECK);														//Check to see if "end" keyword has been received.
		
		/*Skip counter for "beep" feature.*/
		if (j == 1 && BEEP_RESULT > 0) {		//If j = 1 AND "beep" keyword has been received...
			if (BEEP_RESULT > 0) {				//If "beep" keyword has been received...
				Beep(750, 330);					//Make computer beep.
			}
		}
		j = 1;									//Set "j" to 1.

		/*If new datum has been received or if no new datum has been received or if "end" keyword has been received...*/
		if (END_RESULT > 0 || svr_result == SOCKET_ERROR) {
			/*If no new datum has been received...*/
			if (svr_result == SOCKET_ERROR) {
				fprintf(stderr, "Could not receive any data! [Error number: %d]\n", WSAGetLastError());			//Prints last known error.
				fprintf(stderr, "----------------------------------------------------------------------\n");
				closesocket(SvrSocket);			//Close the socket.
				WSACleanup();					//Cleanup.
				exit(0);						//Exit.
			}
			/*If "end" keyword has been received...*/
			if (END_RESULT > 0) {

				fprintf(stderr, "----------------------------------------------------------------------\n");
				fprintf(stderr, "Received client request to END. Proceeding to the next step...\n");
				fprintf(stderr, "----------------------------------------------------------------------\n");

				/************************************************************************************************/
				//[Step5: When the application is finished recieving, shut-down the socket]
				svr_result = shutdown(SvrSocket, SD_RECEIVE);		//Shut-down the socket.
				/*If shutting-down the socket fails...*/
				if (svr_result == SOCKET_ERROR) {
					fprintf(stderr, "Shutdown failed! [Error number: %d]\n", WSAGetLastError());	//Prints last known error.
					fprintf(stderr, "Goodbye!\n");
					closesocket(SvrSocket);		//Close the socket.
					WSACleanup();				//Cleanup.
					exit(0);					//Exit.
				}
				/*Otherwise, continue with program execution.*/
				else {
					fprintf(stderr, "Successfully stopped receiving data! Proceeding to the next step...\n");
					fprintf(stderr, "----------------------------------------------------------------------\n");
				}
				/************************************************************************************************/

				/************************************************************************************************/
				//[Step6: When the application is finished recieving, close the socket]
				/*If closing the socket doesn't yield any errors...*/
				if (closesocket(SvrSocket) == 0) {					//Close the socket.
					fprintf(stderr, "Sucessfully closed the socket! Proceeding to the next step...\n");
				}
				/*Otherwise, halt program and quit.*/
				else {
					fprintf(stderr, "Could not close the socket! [Error number: %d]\n", WSAGetLastError());
					fprintf(stderr, "Goodbye!\n");
					WSACleanup();				//Cleanup.
					exit(0);					//Exit.
				}
				/************************************************************************************************/

				/************************************************************************************************/
				//[Step7: Clean up and quit]
				fprintf(stderr, "----------------------------------------------------------------------\n");
				fprintf(stderr, "All done. Goodbye!\n");
				WSACleanup();					//Cleanup.
				return 0;
				/************************************************************************************************/
			}
		}
	}
	/*********************************************************************************************************/
}
